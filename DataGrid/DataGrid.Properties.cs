
using System;
using System.Collections;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Media;
using ZyunUI.Utilities;
using ZyunUI.DataGridInternals;

namespace ZyunUI
{
    public partial class DataGrid
    {
        /// <summary>
        /// Gets or sets the <see cref="T:System.Windows.Media.Brush"/> that is used to paint the background of odd-numbered rows.
        /// </summary>
        /// <returns>
        /// The brush that is used to paint the background of odd-numbered rows.
        /// </returns>
        public Brush AlternatingRowBackground
        {
            get { return GetValue(AlternatingRowBackgroundProperty) as Brush; }
            set { SetValue(AlternatingRowBackgroundProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="AlternatingRowBackground"/>
        /// dependency property.
        /// </summary>
        /// <returns>
        /// The identifier for the <see cref="AlternatingRowBackground"/>
        /// dependency property.
        /// </returns>
        public static readonly DependencyProperty AlternatingRowBackgroundProperty =
            DependencyProperty.Register(
                "AlternatingRowBackground",
                typeof(Brush),
                typeof(DataGrid),
                new PropertyMetadata(null));

        /// <summary>
        /// Gets or sets the <see cref="T:System.Windows.Media.Brush"/> that is used to paint the foreground of odd-numbered rows.
        /// </summary>
        /// <returns>
        /// The brush that is used to paint the foreground of odd-numbered rows.
        /// </returns>
        public Brush AlternatingRowForeground
        {
            get { return GetValue(AlternatingRowForegroundProperty) as Brush; }
            set { SetValue(AlternatingRowForegroundProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="AlternatingRowForeground"/>
        /// dependency property.
        /// </summary>
        /// <returns>
        /// The identifier for the <see cref="AlternatingRowForeground"/>
        /// dependency property.
        /// </returns>
        public static readonly DependencyProperty AlternatingRowForegroundProperty =
            DependencyProperty.Register(
                "AlternatingRowForeground",
                typeof(Brush),
                typeof(DataGrid),
                new PropertyMetadata(null));

        /// <summary>
        /// Gets or sets a value indicating whether columns are created
        /// automatically when the <see cref="ItemsSource"/> property is set.
        /// </summary>
        public bool AutoGenerateColumns
        {
            get { return (bool)GetValue(AutoGenerateColumnsProperty); }
            set { SetValue(AutoGenerateColumnsProperty, value); }
        }

        /// <summary>
        /// Identifies the AutoGenerateColumns dependency property.
        /// </summary>
        public static readonly DependencyProperty AutoGenerateColumnsProperty =
            DependencyProperty.Register(
                "AutoGenerateColumns",
                typeof(bool),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultAutoGenerateColumns, OnAutoGenerateColumnsPropertyChanged));

        private static void OnAutoGenerateColumnsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            bool value = (bool)e.NewValue;
            if (value)
            {
                //dataGrid.InitializeElements(false /*recycleRows*/);
            }
            else
            {
                //dataGrid.RemoveAutoGeneratedColumns();
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the user can change
        /// the column display order by dragging column headers with the mouse.
        /// </summary>
        public bool CanUserReorderColumns
        {
            get { return (bool)GetValue(CanUserReorderColumnsProperty); }
            set { SetValue(CanUserReorderColumnsProperty, value); }
        }

        /// <summary>
        /// Identifies the CanUserReorderColumns dependency property.
        /// </summary>
        public static readonly DependencyProperty CanUserReorderColumnsProperty =
            DependencyProperty.Register(
                "CanUserReorderColumns",
                typeof(bool),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultCanUserReorderColumns));

        /// <summary>
        /// Gets or sets a value indicating whether the user can adjust column widths using the mouse.
        /// </summary>
        public bool CanUserResizeColumns
        {
            get { return (bool)GetValue(CanUserResizeColumnsProperty); }
            set { SetValue(CanUserResizeColumnsProperty, value); }
        }

        /// <summary>
        /// Identifies the CanUserResizeColumns dependency property.
        /// </summary>
        public static readonly DependencyProperty CanUserResizeColumnsProperty =
            DependencyProperty.Register(
                "CanUserResizeColumns",
                typeof(bool),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultCanUserResizeColumns, OnCanUserResizeColumnsPropertyChanged));

        /// <summary>
        /// CanUserResizeColumns property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its CanUserResizeColumns.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnCanUserResizeColumnsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            //dataGrid.EnsureHorizontalLayout();
        }

        /// <summary>
        /// Gets or sets a value indicating whether the user can sort columns by clicking the column header.
        /// </summary>
        public bool CanUserSortColumns
        {
            get { return (bool)GetValue(CanUserSortColumnsProperty); }
            set { SetValue(CanUserSortColumnsProperty, value); }
        }

        /// <summary>
        /// Identifies the CanUserSortColumns dependency property.
        /// </summary>
        public static readonly DependencyProperty CanUserSortColumnsProperty =
            DependencyProperty.Register(
                "CanUserSortColumns",
                typeof(bool),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultCanUserSortColumns));

        /// <summary>
        /// Gets or sets the style that is used when rendering the data grid cells.
        /// </summary>
        public Style CellStyle
        {
            get { return GetValue(CellStyleProperty) as Style; }
            set { SetValue(CellStyleProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="CellStyle"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CellStyleProperty =
            DependencyProperty.Register(
                "CellStyle",
                typeof(Style),
                typeof(DataGrid),
                new PropertyMetadata(null, OnCellStylePropertyChanged));

        private static void OnCellStylePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            if (dataGrid != null)
            {
                Style previousStyle = e.OldValue as Style;
                //foreach (DataGridRow row in dataGrid.GetAllRows())
                //{
                //    foreach (DataGridCell cell in row.Cells)
                //    {
                //        cell.EnsureStyle(previousStyle);
                //    }

                //    row.FillerCell.EnsureStyle(previousStyle);
                //}

                //dataGrid.InvalidateRowHeightEstimate();
            }
        }

        /// <summary>
        /// Gets or sets the property which determines how DataGrid content is copied to the Clipboard.
        /// </summary>
        public DataGridClipboardCopyMode ClipboardCopyMode
        {
            get { return (DataGridClipboardCopyMode)GetValue(ClipboardCopyModeProperty); }
            set { SetValue(ClipboardCopyModeProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="ClipboardCopyMode"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty ClipboardCopyModeProperty =
            DependencyProperty.Register(
                "ClipboardCopyMode",
                typeof(DataGridClipboardCopyMode),
                typeof(DataGrid),
                new PropertyMetadata(DataGridClipboardCopyMode.ExcludeHeader));

        /// <summary>
        /// Gets or sets the height of the column headers row.
        /// </summary>
        public double ColumnHeaderHeight
        {
            get { return (double)GetValue(ColumnHeaderHeightProperty); }
            set { SetValue(ColumnHeaderHeightProperty, value); }
        }

        /// <summary>
        /// Identifies the ColumnHeaderHeight dependency property.
        /// </summary>
        public static readonly DependencyProperty ColumnHeaderHeightProperty =
            DependencyProperty.Register(
                "ColumnHeaderHeight",
                typeof(double),
                typeof(DataGrid),
                new PropertyMetadata(double.NaN, OnColumnHeaderHeightPropertyChanged));

        /// <summary>
        /// ColumnHeaderHeightProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its ColumnHeaderHeight.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnColumnHeaderHeightPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            if (!dataGrid.IsHandlerSuspended(e.Property))
            {
                double value = (double)e.NewValue;
                if (value < DATAGRID_minimumColumnHeaderHeight)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeGreaterThanOrEqualTo("value", "ColumnHeaderHeight", DATAGRID_minimumColumnHeaderHeight);
                }

                if (value > DATAGRID_maxHeadersThickness)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeLessThanOrEqualTo("value", "ColumnHeaderHeight", DATAGRID_maxHeadersThickness);
                }

                dataGrid.InvalidateMeasure();
            }
        }

        /// <summary>
        /// Gets or sets the style that is used when rendering the column headers.
        /// </summary>
        public Style ColumnHeaderStyle
        {
            get { return GetValue(ColumnHeaderStyleProperty) as Style; }
            set { SetValue(ColumnHeaderStyleProperty, value); }
        }

        /// <summary>
        /// Identifies the ColumnHeaderStyle dependency property.
        /// </summary>
        public static readonly DependencyProperty ColumnHeaderStyleProperty =
            DependencyProperty.Register(
                "ColumnHeaderStyle",
                typeof(Style),
                typeof(DataGrid),
                new PropertyMetadata(null, OnColumnHeaderStylePropertyChanged));

        private static void OnColumnHeaderStylePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            // TODO: ColumnHeaderStyle should be applied to the TopLeftCorner and the TopRightCorner as well
            DataGrid dataGrid = d as DataGrid;
            if (dataGrid != null)
            {
                Style previousStyle = e.OldValue as Style;
                foreach (DataGridColumn column in dataGrid.Columns)
                {
                    //column.HeaderCell.EnsureStyle(previousStyle);
                }

                //if (dataGrid.ColumnsInternal.FillerColumn != null)
                //{
                //    dataGrid.ColumnsInternal.FillerColumn.HeaderCell.EnsureStyle(previousStyle);
                //}
            }
        }

        /// <summary>
        /// Gets or sets the standard width or automatic sizing mode of columns in the control.
        /// </summary>
        public GridLength ColumnWidth
        {
            get { return (GridLength)GetValue(ColumnWidthProperty); }
            set { SetValue(ColumnWidthProperty, value); }
        }

        /// <summary>
        /// Identifies the ColumnWidth dependency property.
        /// </summary>
        public static readonly DependencyProperty ColumnWidthProperty =
            DependencyProperty.Register(
                "ColumnWidth",
                typeof(GridLength),
                typeof(DataGrid),
                new PropertyMetadata(GridLength.Auto, OnColumnWidthPropertyChanged));

        /// <summary>
        /// ColumnWidthProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its ColumnWidth.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnColumnWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;

            //foreach (DataGridColumn column in dataGrid.ColumnsInternal.GetDisplayedColumns())
            //{
            //    if (column.InheritsWidth)
            //    {
            //        column.SetWidthInternalNoCallback(dataGrid.ColumnWidth);
            //    }
            //}

            //dataGrid.EnsureHorizontalLayout();
        }

        /// <summary>
        /// Gets or sets the style that is used when rendering the drag indicator
        /// that is displayed while dragging column headers.
        /// </summary>
        public Style DragIndicatorStyle
        {
            get { return GetValue(DragIndicatorStyleProperty) as Style; }
            set { SetValue(DragIndicatorStyleProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="DragIndicatorStyle"/>
        /// dependency property.
        /// </summary>
        public static readonly DependencyProperty DragIndicatorStyleProperty =
            DependencyProperty.Register(
                "DragIndicatorStyle",
                typeof(Style),
                typeof(DataGrid),
                null);

        /// <summary>
        /// Gets or sets the style that is used when rendering the column headers.
        /// </summary>
        public Style DropLocationIndicatorStyle
        {
            get { return GetValue(DropLocationIndicatorStyleProperty) as Style; }
            set { SetValue(DropLocationIndicatorStyleProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="DropLocationIndicatorStyle"/>
        /// dependency property.
        /// </summary>
        public static readonly DependencyProperty DropLocationIndicatorStyleProperty =
            DependencyProperty.Register(
                "DropLocationIndicatorStyle",
                typeof(Style),
                typeof(DataGrid),
                null);

        /// <summary>
        /// Gets or sets the number of columns that the user cannot scroll horizontally.
        /// </summary>
        public int FrozenColumnCount
        {
            get { return (int)GetValue(FrozenColumnCountProperty); }
            set { SetValue(FrozenColumnCountProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="FrozenColumnCount"/>
        /// dependency property.
        /// </summary>
        public static readonly DependencyProperty FrozenColumnCountProperty =
            DependencyProperty.Register(
                "FrozenColumnCount",
                typeof(int),
                typeof(DataGrid),
                new PropertyMetadata(0, OnFrozenColumnCountPropertyChanged));

        private static void OnFrozenColumnCountPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            //if (!dataGrid.IsHandlerSuspended(e.Property))
            //{
            //    if ((int)e.NewValue < 0)
            //    {
            //        dataGrid.SetValueNoCallback(DataGrid.FrozenColumnCountProperty, e.OldValue);
            //        throw DataGridError.DataGrid.ValueMustBeGreaterThanOrEqualTo("value", "FrozenColumnCount", 0);
            //    }

            //    ProcessFrozenColumnCount(dataGrid);
            //}
        }

        private static void ProcessFrozenColumnCount(DataGrid dataGrid)
        {
            //dataGrid.CorrectColumnFrozenStates();
            //dataGrid.ComputeScrollBarsLayout();

            //dataGrid.InvalidateColumnHeadersArrange();
            //dataGrid.InvalidateCellsArrange();
        }

        /// <summary>
        /// Gets or sets a value indicating which grid lines separating inner cells are shown.
        /// </summary>
        public DataGridGridLinesVisibility GridLinesVisibility
        {
            get { return (DataGridGridLinesVisibility)GetValue(GridLinesVisibilityProperty); }
            set { SetValue(GridLinesVisibilityProperty, value); }
        }

        /// <summary>
        /// Identifies the GridLinesVisibility dependency property.
        /// </summary>
        public static readonly DependencyProperty GridLinesVisibilityProperty =
            DependencyProperty.Register(
                "GridLinesVisibility",
                typeof(DataGridGridLinesVisibility),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultGridLinesVisibility, OnGridLinesVisibilityPropertyChanged));

        /// <summary>
        /// GridLinesProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its GridLines.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnGridLinesVisibilityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            //DataGrid dataGrid = d as DataGrid;
            //foreach (DataGridRow row in dataGrid.GetAllRows())
            //{
            //    row.EnsureGridLines();
            //    row.InvalidateHorizontalArrange();
            //}

            //foreach (DataGridRowGroupHeader rowGroupHeader in dataGrid.GetAllRowGroupHeaders())
            //{
            //    rowGroupHeader.EnsureGridLine();
            //}
        }

        /// <summary>
        /// Gets or sets a value indicating the visibility of row and column headers.
        /// </summary>
        public DataGridHeadersVisibility HeadersVisibility
        {
            get { return (DataGridHeadersVisibility)GetValue(HeadersVisibilityProperty); }
            set { SetValue(HeadersVisibilityProperty, value); }
        }

        /// <summary>
        /// Identifies the HeadersVisibility dependency property.
        /// </summary>
        public static readonly DependencyProperty HeadersVisibilityProperty =
            DependencyProperty.Register(
                "HeadersVisibility",
                typeof(DataGridHeadersVisibility),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultHeadersVisibility, OnHeadersVisibilityPropertyChanged));

        /// <summary>
        /// HeadersVisibilityProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its HeadersVisibility.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnHeadersVisibilityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            DataGridHeadersVisibility newValue = (DataGridHeadersVisibility)e.NewValue;
            DataGridHeadersVisibility oldValue = (DataGridHeadersVisibility)e.OldValue;

            Func<DataGridHeadersVisibility, DataGridHeadersVisibility, bool> hasFlags = (DataGridHeadersVisibility value, DataGridHeadersVisibility flags) => ((value & flags) == flags);

            bool newValueCols = hasFlags(newValue, DataGridHeadersVisibility.Column);
            bool newValueRows = hasFlags(newValue, DataGridHeadersVisibility.Row);
            bool oldValueCols = hasFlags(oldValue, DataGridHeadersVisibility.Column);
            bool oldValueRows = hasFlags(oldValue, DataGridHeadersVisibility.Row);

            // Columns
            //if (newValueCols != oldValueCols)
            //{
            //    if (dataGrid._columnHeadersPresenter != null)
            //    {
            //        dataGrid.EnsureColumnHeadersVisibility();
            //        if (!newValueCols)
            //        {
            //            dataGrid._columnHeadersPresenter.Measure(new Size(0.0, 0.0));
            //        }
            //        else
            //        {
            //            dataGrid.EnsureVerticalGridLines();
            //        }

            //        dataGrid.InvalidateMeasure();
            //    }
            //}

            //// Rows
            //if (newValueRows != oldValueRows && dataGrid._rowsPresenter != null)
            //{
            //    foreach (FrameworkElement element in dataGrid._rowsPresenter.Children)
            //    {
            //        DataGridRow row = element as DataGridRow;
            //        if (row != null)
            //        {
            //            row.EnsureHeaderStyleAndVisibility(null);
            //            if (newValueRows)
            //            {
            //                row.ApplyState(false /*animate*/);
            //                row.EnsureHeaderVisibility();
            //            }
            //        }
            //        else
            //        {
            //            DataGridRowGroupHeader rowGroupHeader = element as DataGridRowGroupHeader;
            //            if (rowGroupHeader != null)
            //            {
            //                rowGroupHeader.EnsureHeaderStyleAndVisibility(null);
            //            }
            //        }
            //    }

            //    dataGrid.InvalidateRowHeightEstimate();
            //    dataGrid.InvalidateRowsMeasure(true /*invalidateIndividualElements*/);
            //}

            //// TODO: This isn't necessary if the TopLeftCorner and the TopRightCorner Autosize to 0.
            //// See if their templates can be changed to do that.
            //if (dataGrid._topLeftCornerHeader != null)
            //{
            //    dataGrid._topLeftCornerHeader.Visibility = (newValueRows && newValueCols) ? Visibility.Visible : Visibility.Collapsed;
            //    if (dataGrid._topLeftCornerHeader.Visibility == Visibility.Collapsed)
            //    {
            //        dataGrid._topLeftCornerHeader.Measure(new Size(0.0, 0.0));
            //    }
            //}
        }

        /// <summary>
        /// Gets or sets the <see cref="T:System.Windows.Media.Brush"/> that is used to paint grid lines separating rows.
        /// </summary>
        public Brush HorizontalGridLinesBrush
        {
            get { return GetValue(HorizontalGridLinesBrushProperty) as Brush; }
            set { SetValue(HorizontalGridLinesBrushProperty, value); }
        }

        /// <summary>
        /// Identifies the HorizontalGridLinesBrush dependency property.
        /// </summary>
        public static readonly DependencyProperty HorizontalGridLinesBrushProperty =
            DependencyProperty.Register(
                "HorizontalGridLinesBrush",
                typeof(Brush),
                typeof(DataGrid),
                new PropertyMetadata(null, OnHorizontalGridLinesBrushPropertyChanged));

        /// <summary>
        /// HorizontalGridLinesBrushProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its HorizontalGridLinesBrush.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnHorizontalGridLinesBrushPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            //if (!dataGrid.IsHandlerSuspended(e.Property) && dataGrid._rowsPresenter != null)
            //{
            //    foreach (DataGridRow row in dataGrid.GetAllRows())
            //    {
            //        row.EnsureGridLines();
            //    }

            //    foreach (DataGridRowGroupHeader rowGroupHeader in dataGrid.GetAllRowGroupHeaders())
            //    {
            //        rowGroupHeader.EnsureGridLine();
            //    }
            //}
        }

        /// <summary>
        /// Gets or sets a value indicating how the horizontal scroll bar is displayed.
        /// </summary>
        public ScrollBarVisibility HorizontalScrollBarVisibility
        {
            get { return (ScrollBarVisibility)GetValue(HorizontalScrollBarVisibilityProperty); }
            set { SetValue(HorizontalScrollBarVisibilityProperty, value); }
        }

        /// <summary>
        /// Identifies the HorizontalScrollBarVisibility dependency property.
        /// </summary>
        public static readonly DependencyProperty HorizontalScrollBarVisibilityProperty =
            DependencyProperty.Register(
                "HorizontalScrollBarVisibility",
                typeof(ScrollBarVisibility),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultScrollBarVisibility, OnHorizontalScrollBarVisibilityPropertyChanged));

        /// <summary>
        /// HorizontalScrollBarVisibilityProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its HorizontalScrollBarVisibility.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnHorizontalScrollBarVisibilityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            if (!dataGrid.IsHandlerSuspended(e.Property) && (ScrollBarVisibility)e.NewValue != (ScrollBarVisibility)e.OldValue)
            {
                dataGrid.UpdateRowsPresenterManipulationMode(true /*horizontalMode*/, false /*verticalMode*/);

                if (dataGrid._hScrollBar != null)
                {
                    dataGrid.ComputeScrollBarsLayout();
                }
            }
        }

        /// <summary>
        /// Gets or sets a value indicating how the vertical scroll bar is displayed.
        /// </summary>
        public ScrollBarVisibility VerticalScrollBarVisibility
        {
            get { return (ScrollBarVisibility)GetValue(VerticalScrollBarVisibilityProperty); }
            set { SetValue(VerticalScrollBarVisibilityProperty, value); }
        }

        /// <summary>
        /// Identifies the VerticalScrollBarVisibility dependency property.
        /// </summary>
        public static readonly DependencyProperty VerticalScrollBarVisibilityProperty =
            DependencyProperty.Register(
                "VerticalScrollBarVisibility",
                typeof(ScrollBarVisibility),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultScrollBarVisibility, OnVerticalScrollBarVisibilityPropertyChanged));

        /// <summary>
        /// VerticalScrollBarVisibilityProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its VerticalScrollBarVisibility.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnVerticalScrollBarVisibilityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            if (!dataGrid.IsHandlerSuspended(e.Property) && (ScrollBarVisibility)e.NewValue != (ScrollBarVisibility)e.OldValue)
            {
                dataGrid.UpdateRowsPresenterManipulationMode(false /*horizontalMode*/, true /*verticalMode*/);

                if (dataGrid._vScrollBar != null)
                {
                    dataGrid.ComputeScrollBarsLayout();
                }
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the user can edit the values in the control.
        /// </summary>
        public bool IsReadOnly
        {
            get { return (bool)GetValue(IsReadOnlyProperty); }
            set { SetValue(IsReadOnlyProperty, value); }
        }

        /// <summary>
        /// Identifies the IsReadOnly dependency property.
        /// </summary>
        public static readonly DependencyProperty IsReadOnlyProperty =
            DependencyProperty.Register(
                "IsReadOnly",
                typeof(bool),
                typeof(DataGrid),
                new PropertyMetadata(false, OnIsReadOnlyPropertyChanged));

        /// <summary>
        /// IsReadOnlyProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its IsReadOnly.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnIsReadOnlyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
//            DataGrid dataGrid = d as DataGrid;
//            if (!dataGrid.IsHandlerSuspended(e.Property))
//            {
//                bool value = (bool)e.NewValue;
//                if (value && !dataGrid.CommitEdit(DataGridEditingUnit.Row, true /*exitEditing*/))
//                {
//                    dataGrid.CancelEdit(DataGridEditingUnit.Row, false /*raiseEvents*/);
//                }

//#if FEATURE_IEDITABLECOLLECTIONVIEW
//                dataGrid.UpdateNewItemPlaceholder();
//#endif
//            }
        }

        /// <summary>
        /// Gets a value indicating whether data in the grid is valid.
        /// </summary>
        public bool IsValid
        {
            get
            {
                return (bool)GetValue(IsValidProperty);
            }

            internal set
            {
                if (value != this.IsValid)
                {
                    if (value)
                    {
                        VisualStates.GoToState(this, true, VisualStates.StateValid);
                    }
                    else
                    {
                        VisualStates.GoToState(this, true, VisualStates.StateInvalid, VisualStates.StateValid);
                    }

                    //this.SetValueNoCallback(DataGrid.IsValidProperty, value);
                }
            }
        }

        /// <summary>
        /// Identifies the IsValid dependency property.
        /// </summary>
        public static readonly DependencyProperty IsValidProperty =
            DependencyProperty.Register(
                "IsValid",
                typeof(bool),
                typeof(DataGrid),
                new PropertyMetadata(true, OnIsValidPropertyChanged));

        /// <summary>
        /// IsValidProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its IsValid.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnIsValidPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            //if (!dataGrid.IsHandlerSuspended(e.Property))
            //{
            //    dataGrid.SetValueNoCallback(DataGrid.IsValidProperty, e.OldValue);
            //    throw DataGridError.DataGrid.UnderlyingPropertyIsReadOnly("IsValid");
            //}
        }

        /// <summary>
        /// Gets or sets a collection that is used to generate the content of the control.
        /// </summary>
        public IList ItemsSource
        {
            get { return GetValue(ItemsSourceProperty) as IList; }
            set { SetValue(ItemsSourceProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="ItemsSource"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty ItemsSourceProperty =
            DependencyProperty.Register(
                "ItemsSource",
                typeof(IList),
                typeof(DataGrid),
                new PropertyMetadata(null, OnItemsSourcePropertyChanged));

        /// <summary>
        /// ItemsSourceProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its ItemsSource.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnItemsSourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            dataGrid.ItemsSourceChanged();
        }

        /// <summary>
        /// Gets or sets the maximum width of columns in the <see cref="DataGrid"/>.
        /// </summary>
        public double MaxColumnWidth
        {
            get { return (double)GetValue(MaxColumnWidthProperty); }
            set { SetValue(MaxColumnWidthProperty, value); }
        }

        /// <summary>
        /// Identifies the MaxColumnWidth dependency property.
        /// </summary>
        public static readonly DependencyProperty MaxColumnWidthProperty =
            DependencyProperty.Register(
                "MaxColumnWidth",
                typeof(double),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultMaxColumnWidth, OnMaxColumnWidthPropertyChanged));

        /// <summary>
        /// MaxColumnWidthProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its ColumnWidth.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnMaxColumnWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            if (!dataGrid.IsHandlerSuspended(e.Property))
            {
                double oldValue = (double)e.OldValue;
                double newValue = (double)e.NewValue;

                if (double.IsNaN(newValue))
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueCannotBeSetToNAN("MaxColumnWidth");
                }

                if (newValue < 0)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeGreaterThanOrEqualTo("value", "MaxColumnWidth", 0);
                }

                if (dataGrid.MinColumnWidth > newValue)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeGreaterThanOrEqualTo("value", "MaxColumnWidth", "MinColumnWidth");
                }

                foreach (DataGridColumn column in dataGrid.ColumnsInternal.GetDisplayedColumns())
                {
                    dataGrid.OnColumnMaxWidthChanged(column, Math.Min(column.MaxWidth, oldValue));
                }
            }
        }

        /// <summary>
        /// Gets or sets the minimum width of columns in the <see cref="DataGrid"/>.
        /// </summary>
        public double MinColumnWidth
        {
            get { return (double)GetValue(MinColumnWidthProperty); }
            set { SetValue(MinColumnWidthProperty, value); }
        }

        /// <summary>
        /// Identifies the MinColumnWidth dependency property.
        /// </summary>
        public static readonly DependencyProperty MinColumnWidthProperty =
            DependencyProperty.Register(
                "MinColumnWidth",
                typeof(double),
                typeof(DataGrid),
                new PropertyMetadata(DATAGRID_defaultMinColumnWidth, OnMinColumnWidthPropertyChanged));

        /// <summary>
        /// MinColumnWidthProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its ColumnWidth.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnMinColumnWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            if (!dataGrid.IsHandlerSuspended(e.Property))
            {
                double oldValue = (double)e.OldValue;
                double newValue = (double)e.NewValue;

                if (double.IsNaN(newValue))
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueCannotBeSetToNAN("MinColumnWidth");
                }

                if (newValue < 0)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeGreaterThanOrEqualTo("value", "MinColumnWidth", 0);
                }

                if (double.IsPositiveInfinity(newValue))
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueCannotBeSetToInfinity("MinColumnWidth");
                }

                if (dataGrid.MaxColumnWidth < newValue)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeLessThanOrEqualTo("value", "MinColumnWidth", "MaxColumnWidth");
                }

                foreach (DataGridColumn column in dataGrid.ColumnsInternal.GetDisplayedColumns())
                {
                    dataGrid.OnColumnMinWidthChanged(column, Math.Max(column.MinWidth, oldValue));
                }
            }
        }

        /// <summary>
        /// Gets or sets the <see cref="T:System.Windows.Media.Brush"/> that is used to paint row backgrounds.
        /// </summary>
        public Brush RowBackground
        {
            get { return GetValue(RowBackgroundProperty) as Brush; }
            set { SetValue(RowBackgroundProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="RowBackground"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty RowBackgroundProperty =
            DependencyProperty.Register(
                "RowBackground",
                typeof(Brush),
                typeof(DataGrid),
                new PropertyMetadata(null, OnRowBackgroundPropertyChanged));

        private static void OnRowBackgroundPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;

            // Go through the Displayed rows and update the background
            //foreach (DataGridRow row in dataGrid.GetAllRows())
            //{
            //    row.EnsureBackground();
            //}
        }

        /// <summary>
        /// Gets or sets the <see cref="T:System.Windows.Media.Brush"/> that is used as the default cells foreground.
        /// </summary>
        public Brush RowForeground
        {
            get { return GetValue(RowForegroundProperty) as Brush; }
            set { SetValue(RowForegroundProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="RowForeground"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty RowForegroundProperty =
            DependencyProperty.Register(
                "RowForeground",
                typeof(Brush),
                typeof(DataGrid),
                new PropertyMetadata(null, OnRowForegroundPropertyChanged));

        private static void OnRowForegroundPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;

            // Go through the Displayed rows and update the foreground
            //foreach (DataGridRow row in dataGrid.GetAllRows())
            //{
            //    row.EnsureForeground();
            //}
        }

        /// <summary>
        /// Gets or sets the standard height of rows in the control.
        /// </summary>
        public double RowHeight
        {
            get { return (double)GetValue(RowHeightProperty); }
            set { SetValue(RowHeightProperty, value); }
        }

        /// <summary>
        /// Identifies the RowHeight dependency property.
        /// </summary>
        public static readonly DependencyProperty RowHeightProperty =
            DependencyProperty.Register(
                "RowHeight",
                typeof(double),
                typeof(DataGrid),
                new PropertyMetadata(double.NaN, OnRowHeightPropertyChanged));

        /// <summary>
        /// RowHeightProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its RowHeight.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnRowHeightPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;

            if (!dataGrid.IsHandlerSuspended(e.Property))
            {
                double value = (double)e.NewValue;

                if (value < DATAGRIDROW_minimumHeight)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeGreaterThanOrEqualTo("value", "RowHeight", 0);
                }

                if (value > DATAGRIDROW_maximumHeight)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeLessThanOrEqualTo("value", "RowHeight", DATAGRIDROW_maximumHeight);
                }

                // DataGrid needs to update the layout information and the ScrollBars
                dataGrid.InvalidateMeasure();
            }
        }

        /// <summary>
        /// Gets or sets the width of the row header column.
        /// </summary>
        public double RowHeaderWidth
        {
            get { return (double)GetValue(RowHeaderWidthProperty); }
            set { SetValue(RowHeaderWidthProperty, value); }
        }

        /// <summary>
        /// Identifies the RowHeaderWidth dependency property.
        /// </summary>
        public static readonly DependencyProperty RowHeaderWidthProperty =
            DependencyProperty.Register(
                "RowHeaderWidth",
                typeof(double),
                typeof(DataGrid),
                new PropertyMetadata(double.NaN, OnRowHeaderWidthPropertyChanged));

        /// <summary>
        /// RowHeaderWidthProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its RowHeaderWidth.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnRowHeaderWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            if (!dataGrid.IsHandlerSuspended(e.Property))
            {
                double value = (double)e.NewValue;

                if (value < DATAGRID_minimumRowHeaderWidth)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeGreaterThanOrEqualTo("value", "RowHeaderWidth", DATAGRID_minimumRowHeaderWidth);
                }

                if (value > DATAGRID_maxHeadersThickness)
                {
                    dataGrid.SetValueNoCallback(e.Property, e.OldValue);
                    throw DataGridError.DataGrid.ValueMustBeLessThanOrEqualTo("value", "RowHeaderWidth", DATAGRID_maxHeadersThickness);
                }

                //dataGrid.EnsureRowHeaderWidth();
            }
        }

        /// <summary>
        /// Gets or sets the style that is used when rendering the row headers.
        /// </summary>
        public Style RowHeaderStyle
        {
            get { return GetValue(RowHeaderStyleProperty) as Style; }
            set { SetValue(RowHeaderStyleProperty, value); }
        }

        /// <summary>
        /// Identifies the <see cref="RowHeaderStyle"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty RowHeaderStyleProperty =
            DependencyProperty.Register(
                "RowHeaderStyle",
                typeof(Style),
                typeof(DataGrid),
                new PropertyMetadata(null, OnRowHeaderStylePropertyChanged));

        private static void OnRowHeaderStylePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            
        }

        /// <summary>
        /// Gets or sets the <see cref="T:System.Windows.Media.Brush"/> that is used to paint grid lines separating columns.
        /// </summary>
        public Brush VerticalGridLinesBrush
        {
            get { return GetValue(VerticalGridLinesBrushProperty) as Brush; }
            set { SetValue(VerticalGridLinesBrushProperty, value); }
        }

        /// <summary>
        /// Identifies the VerticalGridLinesBrush dependency property.
        /// </summary>
        public static readonly DependencyProperty VerticalGridLinesBrushProperty =
            DependencyProperty.Register(
                "VerticalGridLinesBrush",
                typeof(Brush),
                typeof(DataGrid),
                new PropertyMetadata(null, OnVerticalGridLinesBrushPropertyChanged));

        /// <summary>
        /// VerticalGridLinesBrushProperty property changed handler.
        /// </summary>
        /// <param name="d">DataGrid that changed its VerticalGridLinesBrush.</param>
        /// <param name="e">DependencyPropertyChangedEventArgs.</param>
        private static void OnVerticalGridLinesBrushPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            //if (dataGrid._rowsPresenter != null)
            //{
            //    foreach (DataGridRow row in dataGrid.GetAllRows())
            //    {
            //        row.EnsureGridLines();
            //    }
            //}
        }

        public bool CanSelectCells
        {
            get { return (bool)GetValue(CanSelectCellsProperty); }
            set { SetValue(CanSelectCellsProperty, value); }
        }

        /// <summary>
        /// Identifies the AutoGenerateColumns dependency property.
        /// </summary>
        public static readonly DependencyProperty CanSelectCellsProperty =
            DependencyProperty.Register(
                "CanSelectCells",
                typeof(bool),
                typeof(DataGrid),
                new PropertyMetadata(false, CanSelectCellsPropertyChanged));

        private static void CanSelectCellsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DataGrid dataGrid = d as DataGrid;
            bool value = (bool)e.NewValue;
            if (!value)
            {
                dataGrid.ClearSelection();
            }
        }
    }
}